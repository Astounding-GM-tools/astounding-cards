/**
 * AI Image Generation with Gemini
 * 
 * Generates images directly from card content using Gemini's image generation capabilities
 */

import { GoogleGenAI } from '@google/genai';
import { AI_CONFIGS } from '../config/models.js';
import { generateImagePrompt } from '../../next/utils/aiImagePrompt.js';
import { processImage } from '../../utils/image.js';
import type { Card, CardSize } from '../../types.js';
import type { AIResult } from './gemini.js';

export interface ImageGenerationResult extends AIResult<string> {
  imageBlob?: Blob;
  processedBlob?: Blob;
  width?: number;
  height?: number;
}

/**
 * Generate an image for a card using AI
 * 
 * @param apiKey - Google AI Studio API key
 * @param card - Card to generate image for
 * @param deckTheme - Theme for styling (defaults to 'classic')
 * @param cardSize - Card size for proper dimensions (defaults to 'tarot')
 * @returns Promise with image generation result
 */
export async function generateCardImage(
  apiKey: string,
  card: Card,
  deckTheme: string = 'classic',
  cardSize: CardSize = 'tarot'
): Promise<ImageGenerationResult> {
  try {
    const ai = new GoogleGenAI({ apiKey });
    const config = AI_CONFIGS.IMAGE_GENERATION;
    
    // Generate comprehensive image prompt
    const prompt = generateImagePrompt(card, deckTheme);
    console.log(`ðŸŽ¨ Generating image for "${card.title}" with theme: ${deckTheme}`);
    
    // Generate image using Gemini
    const response = await ai.models.generateContent({
      model: config.model,
      contents: [
        {
          role: 'user',
          parts: [{ text: prompt }]
        }
      ],
      config: {
        temperature: config.temperature,
        // Note: Image generation parameters may need adjustment based on actual Gemini API
      }
    });
    
    // Check if we got an image response
    if (!response.images || response.images.length === 0) {
      return {
        success: false,
        error: 'No image generated by AI model'
      };
    }
    
    // Get the first generated image
    const generatedImage = response.images[0];
    
    // Convert to blob (this will depend on the actual Gemini response format)
    const imageBlob = await convertToBlob(generatedImage);
    
    // Process the image to our card specifications
    const processedImage = await processImage(
      new File([imageBlob], 'generated-image.webp', { type: 'image/webp' }),
      cardSize
    );
    
    console.log(`âœ… Image generated and processed (${processedImage.width}x${processedImage.height})`);
    
    return {
      success: true,
      result: 'Image generated successfully',
      imageBlob: imageBlob,
      processedBlob: processedImage.blob,
      width: processedImage.width,
      height: processedImage.height
    };
    
  } catch (error) {
    console.error('Image generation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown image generation error'
    };
  }
}

/**
 * Convert Gemini image response to Blob
 * Note: This function will need to be updated based on the actual Gemini API response format
 */
async function convertToBlob(imageData: any): Promise<Blob> {
  // This is a placeholder implementation
  // The actual implementation will depend on how Gemini returns generated images
  
  if (imageData instanceof Blob) {
    return imageData;
  }
  
  if (typeof imageData === 'string') {
    // Assume it's a base64 string
    const response = await fetch(imageData.startsWith('data:') ? imageData : `data:image/webp;base64,${imageData}`);
    return await response.blob();
  }
  
  if (imageData.data) {
    // Convert array buffer or similar to blob
    return new Blob([imageData.data], { type: 'image/webp' });
  }
  
  throw new Error('Unsupported image data format from Gemini API');
}

/**
 * Test image generation with a simple prompt
 */
export async function testImageGeneration(apiKey: string): Promise<ImageGenerationResult> {
  const testCard: Card = {
    id: 'test',
    title: 'Test Character',
    subtitle: 'Brave Warrior',
    description: 'A valiant knight in shining armor',
    traits: [
      { title: 'Brave', description: 'Fearless in battle', isPublic: true },
      { title: 'Noble', description: 'Acts with honor', isPublic: true }
    ],
    stats: [],
    image: null,
    imageBlob: null,
    imageMetadata: null
  };
  
  return generateCardImage(apiKey, testCard, 'classic', 'tarot');
}
