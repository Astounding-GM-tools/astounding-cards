/**
 * AI Image Generation with Gemini
 *
 * Generates images directly from card content using Gemini's image generation capabilities
 */

import { GoogleGenAI } from '@google/genai';
import { AI_CONFIGS } from '../config/models.js';
import { generateImagePrompt } from '../../next/utils/aiImagePrompt.js';
import { processImage } from '../../utils/image.js';
import type { Card, CardSize } from '../../types.js';
import type { AIResult } from './gemini.js';

export interface ImageGenerationResult extends AIResult<string> {
	imageBlob?: Blob;
	processedBlob?: Blob;
	width?: number;
	height?: number;
}

/**
 * Generate an image for a card using AI
 *
 * @param apiKey - Google AI Studio API key
 * @param card - Card to generate image for
 * @param deckTheme - Theme for styling (defaults to 'classic')
 * @param cardSize - Card size for proper dimensions (defaults to 'tarot')
 * @returns Promise with image generation result
 */
export async function generateCardImage(
	apiKey: string,
	card: Card,
	deckTheme: string = 'classic',
	cardSize: CardSize = 'tarot'
): Promise<ImageGenerationResult> {
	try {
		const ai = new GoogleGenAI({ apiKey });
		const config = AI_CONFIGS.IMAGE_GENERATION;

		// Generate comprehensive image prompt
		const prompt = generateImagePrompt(card, deckTheme);
		console.log(`ðŸŽ¨ Generating image for "${card.title}" with theme: ${deckTheme}`);

		// Generate image using Gemini
		const response = await ai.models.generateContent({
			model: config.model,
			contents: [
				{
					role: 'user',
					parts: [{ text: prompt }]
				}
			],
			config: {
				temperature: config.temperature
				// Note: Image generation parameters may need adjustment based on actual Gemini API
			}
		});

		// Check if we got an image response
		if (!response.images || response.images.length === 0) {
			return {
				success: false,
				error: 'No image generated by AI model'
			};
		}

		// Get the first generated image
		const generatedImage = response.images[0];

		// Convert to blob (this will depend on the actual Gemini response format)
		const imageBlob = await convertToBlob(generatedImage);

		// Process the image to our card specifications
		const processedImage = await processImage(
			new File([imageBlob], 'generated-image.webp', { type: 'image/webp' }),
			cardSize
		);

		console.log(
			`âœ… Image generated and processed (${processedImage.width}x${processedImage.height})`
		);

		return {
			success: true,
			result: 'Image generated successfully',
			imageBlob: imageBlob,
			processedBlob: processedImage.blob,
			width: processedImage.width,
			height: processedImage.height
		};
	} catch (error) {
		console.error('Image generation error:', error);
		return {
			success: false,
			error: error instanceof Error ? error.message : 'Unknown image generation error'
		};
	}
}

/**
 * Convert Gemini image response to Blob
 * Note: This function will need to be updated based on the actual Gemini API response format
 */
async function convertToBlob(imageData: any): Promise<Blob> {
	// This is a placeholder implementation
	// The actual implementation will depend on how Gemini returns generated images

	if (imageData instanceof Blob) {
		return imageData;
	}

	if (typeof imageData === 'string') {
		// Assume it's a base64 string
		const response = await fetch(
			imageData.startsWith('data:') ? imageData : `data:image/webp;base64,${imageData}`
		);
		return await response.blob();
	}

	if (imageData.data) {
		// Convert array buffer or similar to blob
		return new Blob([imageData.data], { type: 'image/webp' });
	}

	throw new Error('Unsupported image data format from Gemini API');
}

/**
 * Test image generation with a simple prompt
 */
export async function testImageGeneration(apiKey: string): Promise<ImageGenerationResult> {
	const testCard: Card = {
		id: 'test',
		title: 'Test Character',
		subtitle: 'Brave Warrior',
		description: 'A valiant knight in shining armor',
		traits: [
			{ title: 'Brave', description: 'Fearless in battle', isPublic: true },
			{ title: 'Noble', description: 'Acts with honor', isPublic: true }
		],
		stats: [],
		image: null,
		imageBlob: null,
		imageMetadata: null
	};

	return generateCardImage(apiKey, testCard, 'classic', 'tarot');
}
