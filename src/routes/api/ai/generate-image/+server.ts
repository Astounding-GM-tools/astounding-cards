/**
 * AI Image Generation API
 *
 * Server-side image generation using Gemini AI with prompt sanitization
 * Replaces client-side BYOK implementation
 */

import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { GEMINI_API_KEY } from '$env/static/private';
import { GoogleGenAI } from '@google/genai';
import { AI_CONFIGS } from '$lib/ai/config/models';
import { generateImagePrompt } from '$lib/next/utils/aiImagePrompt';
import { processPromptForContentFiltering } from '$lib/ai/generators/gemini';
import type { Card, CardSize } from '$lib/types';

export const POST: RequestHandler = async ({ request }) => {
	try {
		// Validate API key is configured
		if (!GEMINI_API_KEY) {
			return error(500, 'Server AI configuration missing');
		}

		// Parse request body
		const { card, deckTheme = 'classic', cardSize = 'tarot' } = await request.json();

		// Validate inputs
		if (!card || typeof card !== 'object') {
			return error(400, 'Card data is required');
		}

		if (!card.title) {
			return error(400, 'Card must have a title');
		}

		console.log(`üé® Server-side image generation for "${card.title}" (theme: ${deckTheme})`);

		const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
		const config = AI_CONFIGS.IMAGE_GENERATION;

		// Step 1: Generate comprehensive image prompt from card
		const rawPrompt = generateImagePrompt(card as Card, deckTheme);
		console.log('üìù Generated raw prompt');

		// Step 2: Sanitize prompt to avoid content filters (removes brand names, real people, etc.)
		console.log('üîç Sanitizing prompt for content filters...');
		const sanitizationResult = await processPromptForContentFiltering(GEMINI_API_KEY, rawPrompt);

		if (!sanitizationResult.success || !sanitizationResult.result) {
			console.error('‚ö†Ô∏è Prompt sanitization failed:', sanitizationResult.error);
			return error(500, 'Failed to sanitize image prompt');
		}

		const sanitizedPrompt = sanitizationResult.result;
		console.log('‚úÖ Prompt sanitized successfully');

		// Step 3: Generate image using sanitized prompt
		console.log('üé® Generating image with Gemini...');
		const response = await ai.models.generateContent({
			model: config.model,
			contents: [
				{
					role: 'user',
					parts: [{ text: sanitizedPrompt }]
				}
			],
			config: {
				temperature: config.temperature
			}
		});

		// Check if we got an image response
		// Note: Actual Gemini image response format needs to be verified
		if (!response.images || response.images.length === 0) {
			console.error('‚ùå No image generated by AI model');
			return error(500, 'No image generated by AI model');
		}

		// Get the first generated image
		const generatedImage = response.images[0];

		// Convert to base64 or data URL for client
		const imageData = await convertImageToBase64(generatedImage);

		console.log(`‚úÖ Image generated successfully for "${card.title}"`);

		return json({
			success: true,
			imageData,
			sanitizedPrompt: sanitizedPrompt, // Include for debugging/transparency
			cardSize
		});
	} catch (err) {
		console.error('Image generation API error:', err);
		return error(500, err instanceof Error ? err.message : 'Failed to generate image');
	}
};

/**
 * Convert Gemini image response to base64 string
 * Note: This function needs to be updated based on actual Gemini API response format
 */
async function convertImageToBase64(imageData: any): Promise<string> {
	// Handle different possible formats from Gemini
	if (typeof imageData === 'string') {
		// Already a base64 string or data URL
		return imageData;
	}

	if (imageData instanceof Blob) {
		// Convert blob to base64
		const buffer = await imageData.arrayBuffer();
		const base64 = Buffer.from(buffer).toString('base64');
		return `data:image/webp;base64,${base64}`;
	}

	if (imageData.data) {
		// Array buffer or similar
		const base64 = Buffer.from(imageData.data).toString('base64');
		return `data:image/webp;base64,${base64}`;
	}

	throw new Error('Unsupported image data format from Gemini API');
}
